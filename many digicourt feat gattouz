#include <ESP32-HUB75-MatrixPanel-I2S-DMA.h>
#include <esp_now.h>
#include <WiFi.h>
#include <vector>

// -------- MATRICE --------
#define PANEL_RES_X 64
#define PANEL_RES_Y 32
#define PANEL_CHAIN 1

HUB75_I2S_CFG mxconfig(PANEL_RES_X, PANEL_RES_Y, PANEL_CHAIN);
MatrixPanel_I2S_DMA *dma_display;

// -------- ÉTATS DU SYSTÈME --------
enum SystemState {
  STATE_BOOT,
  STATE_GAME,
  STATE_MENU_GAMES,    // Choix du nombre de jeux (4, 5, 6)
  STATE_MENU_ADVANTAGE // Choix de la règle d'avantage
};

SystemState currentState = STATE_BOOT;

// -------- CONFIGURATION JEU (Variables) --------
int configGamesPerSet = 6;    // Par défaut 6 jeux
int configAdvantageMode = 0;  // 0: Ad, 1: Punto de Oro, 2: 3Ad

const char* advModeNames[] = {"STD", "Punto Oro", "3AD"};

// -------- SCORE DATA --------
int pointsTeam1_raw = 0;
int pointsTeam2_raw = 0;
int gamesTeam1 = 0;
int gamesTeam2 = 0;
int setScores1[3] = {0, 0, 0};
int setScores2[3] = {0, 0, 0};
int currentSetIdx = 0;
bool advTeam1 = false;
bool advTeam2 = false;
bool inTieBreak = false;
bool tieBreakTriggered = false; // Pour déclencher l'anim une seule fois

std::vector<int> currentGameActions; // Historique des points du match
const char* pointStr[] = {"0", "15", "30", "40"};

// -------- ANIMATIONS / BLINK --------
bool blinkActive = false;
unsigned long blinkStartTime = 0;
unsigned long lastBlinkToggle = 0;
bool blinkVisible = true;
int blinkTeam = 0; 
int lastP1 = 0; 
int lastP2 = 0;

bool tieBreakAnimationActive = false;
unsigned long tieBreakAnimationStart = 0;
bool tieBreakVisible = true;
unsigned long lastTieBreakToggle = 0;

bool specialMessageActive = false;
unsigned long specialMessageStart = 0;

// -------- PROTOTYPES --------
void drawScore();
void drawMenu();
void recalcPoints();

// ================= MENUS =================
void enterMenu() {
  currentState = STATE_MENU_GAMES;
  drawMenu();
}
void drawIntro() {
    dma_display->clearScreen();
    dma_display->setTextSize(1);
    dma_display->setTextColor(dma_display->color565(0, 255, 255)); // Blanc
    // Centrage : "DIGICOURT" fait 9 lettres. 9*6px = 54px.
    // (64 - 54) / 2 = 5 pour X.
    dma_display->setCursor(5, 12); 
    dma_display->print("DIGICOURT");
}
void nextMenuStep() {
  if (currentState == STATE_MENU_GAMES) {
    currentState = STATE_MENU_ADVANTAGE;
  } else if (currentState == STATE_MENU_ADVANTAGE) {
    // Fin du menu, on applique et on reset le set en cours si besoin
    // (Note : changer les règles en plein match recalculera tout l'historique avec les nouvelles règles)
    currentState = STATE_GAME;
    recalcPoints();
  }
  drawMenu();
}

void menuAction(int direction) { // +1 ou -1
  if (currentState == STATE_MENU_GAMES) {
    configGamesPerSet += direction;
    if (configGamesPerSet < 1) configGamesPerSet = 1;
    if (configGamesPerSet > 9) configGamesPerSet = 9;
  } 
  else if (currentState == STATE_MENU_ADVANTAGE) {
    configAdvantageMode += direction;
    if (configAdvantageMode < 0) configAdvantageMode = 2; // Boucle
    else if (configAdvantageMode > 2) configAdvantageMode = 0;
  }
  drawMenu();
}

void drawMenu() {
  dma_display->clearScreen();
  dma_display->setTextSize(1);
  dma_display->setTextColor(dma_display->color565(0, 255, 255)); // Jaune
  
  if (currentState == STATE_GAME) {
    drawScore();
    return;
  }

  dma_display->setCursor(2, 2);
  dma_display->print("MENU");
  
  dma_display->setTextColor(dma_display->color565(0, 255, 255)); // Cyan
  dma_display->setCursor(2, 12);

  if (currentState == STATE_MENU_GAMES) {
    dma_display->print("JEUX/SET:");
    dma_display->setTextSize(1); // Gros chiffre
    dma_display->setCursor(0, 22);
    dma_display->print("> ");
    dma_display->print(configGamesPerSet);
  } 
  else if (currentState == STATE_MENU_ADVANTAGE) {
    dma_display->print("REGLE AD:");
    dma_display->setTextSize(1); // Texte normal
    dma_display->setCursor(0, 22);
    dma_display->print(">");
    dma_display->print(advModeNames[configAdvantageMode]);
  }
}

// ================= LOGIQUE SERVER =================
bool computeServer(bool tieBreak, int p1, int p2, int g1, int g2) {
    int totalGames = g1 + g2;
    // Note: Cela ne prend pas en compte les sets précédents, 
    // pour un vrai suivi serveur sur tout le match il faudrait sommer tous les jeux de tous les sets.
    // Ici simplifié au set courant.
    bool serverA = (totalGames % 2 == 0); 
    if (!tieBreak) return serverA;
    
    int totalPoints = p1 + p2;
    if (totalPoints == 0) return serverA;
    return ((totalPoints - 1) / 2) % 2 == 0 ? !serverA : serverA;
}

void recalcPoints() {
    int p1 = 0, p2 = 0, g1 = 0, g2 = 0;
    int s1[3] = {0}, s2[3] = {0}, setIdx = 0;
    bool tieBreak = false;
    
    int deuceCountInGame = 0; 

    // --- 1. RECALCUL DE L'HISTORIQUE ---
    for (int act : currentGameActions) {
        if (act == 1) p1++; else p2++;

        if (tieBreak) {
            if (p1 >= 7 && p1 - p2 >= 2) { 
                s1[setIdx] = g1 + 1; s2[setIdx] = g2;
                g1 = g2 = p1 = p2 = 0; setIdx++; tieBreak = false; 
            } else if (p2 >= 7 && p2 - p1 >= 2) { 
                s1[setIdx] = g1; s2[setIdx] = g2 + 1;
                g1 = g2 = p1 = p2 = 0; setIdx++; tieBreak = false; 
            }
        } else {
            if (p1 >= 3 && p2 >= 3 && p1 == p2) deuceCountInGame++;

            bool gameWon = false;
            bool isGoldenPoint = false;

            if (configAdvantageMode == 1) { 
                if (p1 >= 3 && p2 >= 3) isGoldenPoint = true;
            } 
            else if (configAdvantageMode == 2) {
                if (deuceCountInGame >= 3) isGoldenPoint = true;
            } 

            if (isGoldenPoint) {
                if (p1 > p2) gameWon = true;
                else if (p2 > p1) gameWon = true;
            } else {
                if (p1 > 3 && p1 >= p2 + 2) gameWon = true;
                else if (p2 > 3 && p2 >= p1 + 2) gameWon = true;
            }

            if (gameWon) {
                if (p1 > p2) g1++; else g2++;
                p1 = p2 = 0;
                deuceCountInGame = 0;
            }

            if (g1 == configGamesPerSet && g2 == configGamesPerSet) {
                tieBreak = true;
            }
            else if ((g1 >= configGamesPerSet && g1 - g2 >= 2) || g1 == configGamesPerSet + 1) {
                s1[setIdx]=g1; s2[setIdx]=g2; g1=g2=0; setIdx++;
            }
            else if ((g2 >= configGamesPerSet && g2 - g1 >= 2) || g2 == configGamesPerSet + 1) {
                s1[setIdx]=g1; s2[setIdx]=g2; g1=g2=0; setIdx++;
            }
        }
    }

    // --- 2. GESTION ETAT VISUEL (BLINK) ---
    if (currentState == STATE_GAME) {
        if (p1 != lastP1) blinkTeam = 1;
        else if (p2 != lastP2) blinkTeam = 2;
        
        if (p1 != lastP1 || p2 != lastP2) {
            blinkActive = true; 
            blinkStartTime = millis(); 
            lastBlinkToggle = millis();
            blinkVisible = true;
        }
    }

    lastP1 = p1; lastP2 = p2;
    pointsTeam1_raw = p1; pointsTeam2_raw = p2;
    gamesTeam1 = g1; gamesTeam2 = g2;
    currentSetIdx = min(setIdx, 2);

    // --- MODIFICATION ICI ---
    if (tieBreak) {
        // Si on entre en tie break et que l'anim n'a pas encore été déclenchée
        if (!tieBreakTriggered && currentState == STATE_GAME) {
            tieBreakTriggered = true;
            tieBreakAnimationActive = true;
            tieBreakAnimationStart = millis();
        }
    } else {
        // IMPORTANT : Si on n'est PAS en tie break, on réarme le trigger pour la prochaine fois
        tieBreakTriggered = false;
    }
    
    inTieBreak = tieBreak;

    for (int i = 0; i < 3; i++) { setScores1[i] = s1[i]; setScores2[i] = s2[i]; }

    // --- 3. CALCUL AFFICHAGE "Ad" ---
    if (!tieBreak) {
        advTeam1 = (p1 >= 3 && p2 >= 3 && p1 == p2 + 1);
        advTeam2 = (p2 >= 3 && p1 >= 3 && p2 == p1 + 1);
    } else {
        advTeam1 = false;
        advTeam2 = false;
    }

    if (currentState == STATE_GAME) drawScore();
}
// ================= DISPLAY HELPERS =================
void drawBall(int x, int y, uint16_t color) {
    for(int dx=0;dx<3;dx++) for(int dy=0;dy<3;dy++) dma_display->drawPixel(x+dx, y+dy, color);
}

void drawSpecialMessage() {
    dma_display->clearScreen();
    dma_display->setTextSize(1);
    dma_display->setTextColor(dma_display->color565(0,255,255));
    dma_display->setCursor(16, 7);  dma_display->print("GROSSE");
    dma_display->setCursor(16, 17); dma_display->print("MERDE");
}

void drawTieBreakAnimation() {
    uint16_t c = dma_display->color565(0, 255, 255);
    
    // --- MODIFICATION ICI ---
    dma_display->setTextSize(1); // Force la taille 1 (petit texte)
    
    if(tieBreakVisible) {
        // "TIE BREAK" = 9 caractères
        // En taille 1, ça prend environ 54 pixels de large.
        // Écran 64px - 54px = 10px de marge => X = 5 pour centrer.
        dma_display->setCursor(5, 12); 
        dma_display->setTextColor(c);
        dma_display->print("TIE BREAK");
    }
}

// ================= DISPLAY MAIN =================
void drawScore() {
    if (currentState != STATE_GAME) { drawMenu(); return; }

    if (specialMessageActive) { drawSpecialMessage(); return; }
    
    if (tieBreakAnimationActive) {
        dma_display->clearScreen();
        drawTieBreakAnimation();
        return;
    }

    dma_display->clearScreen();
    
    uint16_t c1 = dma_display->color565(255, 0, 0);
    uint16_t c2 = dma_display->color565(0, 255, 0);
    bool srvA = computeServer(inTieBreak, pointsTeam1_raw, pointsTeam2_raw, gamesTeam1, gamesTeam2);

    // Textes points
    String sP1, sP2;
    if (inTieBreak) {
        sP1 = String(pointsTeam1_raw); sP2 = String(pointsTeam2_raw);
    } else {
        if (advTeam1) { sP1="Ad"; sP2="40"; }
        else if (advTeam2) { sP1="40"; sP2="Ad"; }
        else {
            // Gestion affichage 40-40 spécial
            if (pointsTeam1_raw >=3 && pointsTeam2_raw >=3) { sP1="40"; sP2="40"; }
            else { sP1=pointStr[pointsTeam1_raw]; sP2=pointStr[pointsTeam2_raw]; }
        }
    }

    // -- DRAW TEAM A --
    dma_display->setTextSize(1); dma_display->setTextColor(c1);
    dma_display->setCursor(1, 4); dma_display->print("A");
    for(int i=0; i<3; i++) {
        if(i<=currentSetIdx) {
            dma_display->setCursor(15+(i*9), 4);
            dma_display->print(i==currentSetIdx ? gamesTeam1 : setScores1[i]);
        }
    }
    dma_display->setTextSize(2); 
    int x1 = 40 + (sP1.length()==1 ? 6:0);
    dma_display->setCursor(x1, 1);
    if(!blinkActive || blinkTeam!=1 || blinkVisible) dma_display->print(sP1);
    if(srvA) drawBall(8, 6, c1);

    // -- DRAW TEAM B --
    dma_display->setTextSize(1); dma_display->setTextColor(c2);
    dma_display->setCursor(1, 20); dma_display->print("B");
    for(int i=0; i<3; i++) {
        if(i<=currentSetIdx) {
            dma_display->setCursor(15+(i*9), 20);
            dma_display->print(i==currentSetIdx ? gamesTeam2 : setScores2[i]);
        }
    }
    dma_display->setTextSize(2);
    int x2 = 40 + (sP2.length()==1 ? 6:0);
    dma_display->setCursor(x2, 17);
    if(!blinkActive || blinkTeam!=2 || blinkVisible) dma_display->print(sP2);
    if(!srvA) drawBall(8, 22, c2);
}

// ================= COMMS =================
typedef struct struct_message { int action; } struct_message;
struct_message incomingData;

void scorePoint(int t) { currentGameActions.push_back(t); recalcPoints(); }
void undoLast() { if(!currentGameActions.empty()){ currentGameActions.pop_back(); recalcPoints(); }}
void resetAll() { 
    currentGameActions.clear(); 
    tieBreakTriggered=false; 
    tieBreakAnimationActive=false; 
    recalcPoints(); 
}

void onReceive(const esp_now_recv_info *info, const uint8_t *data, int len) {
    memcpy(&incomingData, data, sizeof(incomingData));
    int act = incomingData.action;

    if (act == 6) { 
        // Signal MENU (Appui long Btn 2)
        if (currentState == STATE_GAME) enterMenu();
        else { currentState = STATE_GAME; drawMenu(); } // Sortie d'urgence du menu
        return; 
    }

    if (currentState != STATE_GAME) {
        // --- NAVIGATION MENU ---
        if (act == 1) menuAction(1);       // Btn 1: + / Suivant
        else if (act == 3) menuAction(-1); // Btn 3: - / Précédent
        else if (act == 2) nextMenuStep(); // Btn 2: Valider
    } else {
        // --- JEU NORMAL ---
        switch(act) {
            case 1: scorePoint(1); break;
            case 2: scorePoint(2); break;
            case 3: undoLast(); break;
            case 4: resetAll(); break;
            case 5: 
                specialMessageActive = true; 
                specialMessageStart = millis(); 
                drawScore(); 
                break;
        }
    }
}

// ================= SETUP / LOOP =================
void setup() {
    // Config Matrix (A ajuster selon ton câblage)
    mxconfig.gpio.r1=18; mxconfig.gpio.g1=25; mxconfig.gpio.b1=5;
    mxconfig.gpio.r2=22; mxconfig.gpio.g2=33; mxconfig.gpio.b2=16;
    mxconfig.gpio.a=4; mxconfig.gpio.b=3; mxconfig.gpio.c=0;
    mxconfig.gpio.d=21; mxconfig.gpio.e=32;
    mxconfig.gpio.lat=19; mxconfig.gpio.oe=15; mxconfig.gpio.clk=2;

    dma_display = new MatrixPanel_I2S_DMA(mxconfig);
    dma_display->begin();
    dma_display->setBrightness8(150);

    WiFi.mode(WIFI_STA);
    esp_now_init();
    esp_now_register_recv_cb(onReceive);

    drawIntro(); // Affiche le score initial (0-0)
}

void loop() {
    unsigned long now = millis();

  // --- 0. GESTION DU DEMARRAGE (10 SECONDES) ---
    if (currentState == STATE_BOOT) {
        if (now > 10000) { // Après 10 000 ms (10 sec)
            currentState = STATE_GAME;
            recalcPoints(); // On lance le match et l'affichage du score
        }
        return; // On empêche le reste de la boucle de s'exécuter pendant l'intro
    }
    // 1. Gestion message spécial (Grosse Merde)
    if (specialMessageActive && now - specialMessageStart > 5000) {
        specialMessageActive = false;
        drawScore();
    }

    // 2. Anim Tie Break
    if (tieBreakAnimationActive) {
        if (now - tieBreakAnimationStart > 3000) {
            tieBreakAnimationActive = false;
            drawScore();
        } else if (now - lastTieBreakToggle > 300) {
            tieBreakVisible = !tieBreakVisible;
            lastTieBreakToggle = now;
            drawScore();
        }
    }

    // 3. Blink des points
    if (blinkActive && currentState == STATE_GAME) {
        if (now - blinkStartTime > 3000) {
            blinkActive = false; blinkVisible = true; drawScore();
        } else if (now - lastBlinkToggle > 300) {
            blinkVisible = !blinkVisible; lastBlinkToggle = now; drawScore();
        }
    }
    delay(10);
}
