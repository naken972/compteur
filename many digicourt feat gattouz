#include <ESP32-HUB75-MatrixPanel-I2S-DMA.h>
#include <esp_now.h>
#include <WiFi.h>
#include <vector>

#define PANEL_RES_X 64
#define PANEL_RES_Y 32
#define PANEL_CHAIN 1

HUB75_I2S_CFG mxconfig(PANEL_RES_X, PANEL_RES_Y, PANEL_CHAIN);
MatrixPanel_I2S_DMA *dma_display;

// ================= SCORE STATE =================
int pointsTeam1_raw = 0;
int pointsTeam2_raw = 0;
int gamesTeam1 = 0;
int gamesTeam2 = 0;
int setScores1[3] = {0, 0, 0};
int setScores2[3] = {0, 0, 0};
int currentSetIdx = 0;
bool advTeam1 = false;
bool advTeam2 = false;
bool inTieBreak = false;

std::vector<int> currentGameActions;
const char* pointStr[] = {"0", "15", "30", "40"};

// ================= SERVER LOGIC =================
bool computeServer(bool tieBreak, int p1, int p2, int g1, int g2) {
    int totalGames = g1 + g2;
    bool serverA = (totalGames % 2 == 0);  // A sert au d√©but
    if (!tieBreak) return serverA;

    int totalPoints = p1 + p2;
    if (totalPoints == 0) return serverA;

    return ((totalPoints - 1) / 2) % 2 == 0 ? !serverA : serverA;
}

// ================= SMALL 3x3 BALL =================
void drawBall(int x, int y, uint16_t color) {
    for (int dx = 0; dx < 3; dx++)
        for (int dy = 0; dy < 3; dy++)
            dma_display->drawPixel(x + dx, y + dy, color);
}

// ================= DISPLAY =================
void drawScore() {
    dma_display->clearScreen();
    dma_display->setTextWrap(false);

    uint16_t colorT1 = dma_display->color565(255, 0, 0);   // Rouge pour A
    uint16_t colorT2 = dma_display->color565(0, 255, 0);   // Vert pour B

    bool team1Serving = computeServer(inTieBreak, pointsTeam1_raw, pointsTeam2_raw, gamesTeam1, gamesTeam2);

    String p1, p2;
    if (inTieBreak) {
        p1 = String(pointsTeam1_raw);
        p2 = String(pointsTeam2_raw);
    } else if (advTeam1) { p1 = "Ad"; p2 = "40"; }
    else if (advTeam2) { p1 = "40"; p2 = "Ad"; }
    else if (pointsTeam1_raw >= 3 && pointsTeam2_raw >= 3) { p1 = "40"; p2 = "40"; }
    else { p1 = pointStr[pointsTeam1_raw]; p2 = pointStr[pointsTeam2_raw]; }

    // ===== TEAM A =====
    dma_display->setTextSize(1);
    dma_display->setTextColor(colorT1);
    dma_display->setCursor(1, 4);
    dma_display->print("A");

    // Jeux
    for (int i = 0; i < 3; i++) {
        if (i <= currentSetIdx) {
            dma_display->setCursor(16 + (i * 10), 4);
            dma_display->print(i == currentSetIdx ? gamesTeam1 : setScores1[i]);
        }
    }

    // Points
    dma_display->setTextSize(2);
    dma_display->setTextColor(colorT1);
    int x1 = 40;
    if (p1.length() == 1) x1 += 6;
    dma_display->setCursor(x1, 1);
    dma_display->print(p1);

    if (team1Serving) drawBall(8, 6, colorT1);

    // ===== TEAM B =====
    dma_display->setTextSize(1);
    dma_display->setTextColor(colorT2);
    dma_display->setCursor(1, 20);
    dma_display->print("B");

    for (int i = 0; i < 3; i++) {
        if (i <= currentSetIdx) {
            dma_display->setCursor(16 + (i * 10), 20);
            dma_display->print(i == currentSetIdx ? gamesTeam2 : setScores2[i]);
        }
    }

    dma_display->setTextSize(2);
    dma_display->setTextColor(colorT2);
    int x2 = 40;
    if (p2.length() == 1) x2 += 6;
    dma_display->setCursor(x2, 17);
    dma_display->print(p2);

    if (!team1Serving) drawBall(8, 22, colorT2);
}

// ================= RESET FUNCTION =================
void resetScore() {
    pointsTeam1_raw = 0;
    pointsTeam2_raw = 0;
    gamesTeam1 = 0;
    gamesTeam2 = 0;
    currentSetIdx = 0;
    inTieBreak = false;
    advTeam1 = false;
    advTeam2 = false;
    currentGameActions.clear();
    for (int i = 0; i < 3; i++) { setScores1[i] = 0; setScores2[i] = 0; }
    drawScore();
}

// ================= SCORE ENGINE =================
void recalcPoints() {
    int p1 = 0, p2 = 0, g1 = 0, g2 = 0, s1[3] = {0}, s2[3] = {0}, setIdx = 0;
    bool tieBreak = false;

    for (int act : currentGameActions) {
        if (act == 1) p1++; else p2++;

        if (tieBreak) {
            if (p1 >= 7 && p1 - p2 >= 2) { s1[setIdx]=g1; s2[setIdx]=g2; g1=g2=p1=p2=0; setIdx++; tieBreak=false; }
            else if (p2 >= 7 && p2 - p1 >= 2) { s1[setIdx]=g1; s2[setIdx]=g2; g1=g2=p1=p2=0; setIdx++; tieBreak=false; }
        } else {
            if (p1 > 3 && p1 >= p2 + 2) { g1++; p1=p2=0; }
            else if (p2 > 3 && p2 >= p1 + 2) { g2++; p1=p2=0; }

            if (g1 == 6 && g2 == 6) tieBreak = true;
            else if ((g1 >= 6 && g1 - g2 >= 2) || g1 == 7) { s1[setIdx]=g1; s2[setIdx]=g2; g1=g2=0; setIdx++; }
            else if ((g2 >= 6 && g2 - g1 >= 2) || g2 == 7) { s1[setIdx]=g1; s2[setIdx]=g2; g1=g2=0; setIdx++; }
        }
    }

    pointsTeam1_raw = p1;
    pointsTeam2_raw = p2;
    gamesTeam1 = g1;
    gamesTeam2 = g2;
    currentSetIdx = min(setIdx, 2);
    inTieBreak = tieBreak;

    for (int i = 0; i < 3; i++) { setScores1[i] = s1[i]; setScores2[i] = s2[i]; }

    advTeam1 = (!tieBreak && p1 >= 3 && p2 >= 3 && p1 == p2 + 1);
    advTeam2 = (!tieBreak && p2 >= 3 && p1 >= 3 && p2 == p1 + 1);

    drawScore();
}

void scorePoint(int team){ currentGameActions.push_back(team); recalcPoints(); }
void undoLast(){ if(!currentGameActions.empty()){ currentGameActions.pop_back(); recalcPoints(); }}

// ================= ESP NOW =================
typedef struct struct_message { int action; } struct_message;
struct_message incomingData;

void onReceive(const esp_now_recv_info *info, const uint8_t *data, int len){
    memcpy(&incomingData, data, sizeof(incomingData));
    switch(incomingData.action){
        case 1: scorePoint(1); break;
        case 2: scorePoint(2); break;
        case 3: undoLast(); break;
        case 4: resetScore(); break;  // RESET long press
    }
}

// ================= SETUP =================
void setup(){
    mxconfig.gpio.r1=18; mxconfig.gpio.g1=25; mxconfig.gpio.b1=5;
    mxconfig.gpio.r2=22; mxconfig.gpio.g2=33; mxconfig.gpio.b2=16;
    mxconfig.gpio.a=4; mxconfig.gpio.b=3; mxconfig.gpio.c=0; mxconfig.gpio.d=21; mxconfig.gpio.e=32;
    mxconfig.gpio.lat=19; mxconfig.gpio.oe=15; mxconfig.gpio.clk=2;

    dma_display = new MatrixPanel_I2S_DMA(mxconfig);
    dma_display->begin();
    dma_display->setBrightness8(150);

    WiFi.mode(WIFI_STA);
    esp_now_init();
    esp_now_register_recv_cb(onReceive);

    recalcPoints();
}

void loop(){ delay(10); }
